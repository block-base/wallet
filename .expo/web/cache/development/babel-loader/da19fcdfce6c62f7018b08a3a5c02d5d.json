{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport crypto from \"crypto\";\nexport var constants = {\n  did: {\n    methodName: \"ion\",\n    publicKeyType: \"EcdsaSecp256k1VerificationKey2019\",\n    keyId: \"signingKey\"\n  },\n  jwt: {\n    header: {\n      alg: \"ES256K\"\n    },\n    payload: {\n      iss: \"https://self-issued.me\",\n      iat: 0,\n      exp: 9999999999\n    }\n  },\n  jwk: {\n    kty: \"EC\",\n    crv: \"P-256K\"\n  },\n  ecdh: {\n    crv: \"secp256k1\"\n  },\n  hash: {\n    type: \"sha256\",\n    fc: 0x12\n  },\n  pem: {\n    pre: \"-----BEGIN EC PRIVATE KEY-----\\n\",\n    post: \"\\n-----END EC PRIVATE KEY-----\"\n  },\n  asn1: {\n    pre: \"302e0201010420\",\n    post: \"a00706052b8104000a\"\n  }\n};\nexport var base64url = {\n  encode: function encode(unencoded) {\n    return Buffer.from(unencoded).toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n  },\n  decode: function decode(encoded) {\n    encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n    while (encoded.length % 4) {\n      encoded += \"=\";\n    }\n\n    return Buffer.from(encoded, \"base64\").toString(\"utf8\");\n  }\n};\nexport var jwt = {\n  decode: function decode(jwt) {\n    var payload = JSON.parse(base64url.decode(jwt.split(\".\")[1]));\n    return payload;\n  }\n};\nexport var multihash = function multihash(data) {\n  var digest = crypto.createHash(constants.hash.type).update(data).digest();\n  var prefix = Buffer.from([constants.hash.fc, digest.length]);\n  return Buffer.concat([prefix, digest]);\n};\nexport var generateJti = function generateJti() {\n  return crypto.randomBytes(16).toString(\"hex\");\n};\nexport var generatePrivateKey = function generatePrivateKey() {\n  return crypto.randomBytes(32).toString(\"hex\");\n};\nexport var privateKeyToPem = function privateKeyToPem(privateKey) {\n  var asn1 = \"\" + constants.asn1.pre + privateKey + constants.asn1.post;\n  var asn1Base64 = Buffer.from(asn1, \"hex\").toString(\"base64\");\n  var pem = \"\" + constants.pem.pre + asn1Base64 + constants.pem.post;\n  return pem;\n};\nexport var privateKeyToJwk = function privateKeyToJwk(privateKey) {\n  var privateKeyBuffer = Buffer.from(privateKey, \"hex\");\n  var ecdh = crypto.createECDH(constants.ecdh.crv);\n  ecdh.setPrivateKey(privateKeyBuffer);\n  var pub = ecdh.getPublicKey();\n  var publicKeyJwk = {\n    kty: constants.jwk.kty,\n    crv: constants.jwk.crv,\n    x: base64url.encode(pub.slice(1, 32 + 1)),\n    y: base64url.encode(pub.slice(32 + 1))\n  };\n\n  var privateKeyJwk = _objectSpread({\n    d: base64url.encode(privateKeyBuffer)\n  }, publicKeyJwk);\n\n  return {\n    publicKeyJwk: publicKeyJwk,\n    privateKeyJwk: privateKeyJwk\n  };\n};\nexport var publicKeyJwkToIonDid = function publicKeyJwkToIonDid(publicKeyJwk) {\n  var id = constants.did.keyId;\n  var canonical_jwk = JSON.stringify(publicKeyJwk);\n  var commitment_hash = base64url.encode(multihash(canonical_jwk));\n  var patches = [{\n    action: \"replace\",\n    document: {\n      public_keys: [{\n        id: id,\n        type: constants.did.publicKeyType,\n        jwk: publicKeyJwk,\n        purpose: [\"auth\", \"general\"]\n      }]\n    }\n  }];\n  var canonical_delta = JSON.stringify({\n    update_commitment: commitment_hash,\n    patches: patches\n  });\n  var delta = base64url.encode(canonical_delta);\n  var delta_hash = base64url.encode(multihash(canonical_delta));\n  var canonical_suffix_data = JSON.stringify({\n    delta_hash: delta_hash,\n    recovery_commitment: commitment_hash\n  });\n  var didUniqueSuffix = base64url.encode(multihash(canonical_suffix_data));\n  var suffix_data = base64url.encode(canonical_suffix_data);\n  var shortFormDid = \"did:\" + constants.did.methodName + \":\" + didUniqueSuffix;\n  var longFormDid = shortFormDid + \"?-\" + constants.did.methodName + \"-initial-state=\" + suffix_data + \".\" + delta;\n  return longFormDid;\n};\nexport var Wallet = function Wallet(privateKey) {\n  var _this = this;\n\n  _classCallCheck(this, Wallet);\n\n  this.siop = function (options) {\n    var jti = generateJti();\n    var header = {\n      alg: constants.jwt.header.alg,\n      kid: _this.did + \"#\" + constants.did.keyId\n    };\n\n    var payload = _objectSpread({\n      iss: constants.jwt.payload.iss,\n      iat: constants.jwt.payload.iat,\n      exp: constants.jwt.payload.exp,\n      did: _this.did,\n      jti: jti,\n      sub_jwk: _this.publicKeyJwk\n    }, options);\n\n    return _this.sign(header, payload);\n  };\n\n  this.sign = function (header, payload) {\n    var pem = privateKeyToPem(_this.privateKey);\n    var encodedHeader = base64url.encode(JSON.stringify(header));\n    var encodedPayload = base64url.encode(JSON.stringify(payload));\n    var message = encodedHeader + \".\" + encodedPayload;\n    var signature = base64url.encode(crypto.createSign(constants.hash.type).update(message).sign(pem));\n    var result = encodedHeader + \".\" + encodedPayload + \".\" + signature;\n    return result;\n  };\n\n  this.privateKey = privateKey ? privateKey : generatePrivateKey();\n\n  var _privateKeyToJwk = privateKeyToJwk(this.privateKey),\n      publicKeyJwk = _privateKeyToJwk.publicKeyJwk,\n      privateKeyJwk = _privateKeyToJwk.privateKeyJwk;\n\n  this.publicKeyJwk = publicKeyJwk;\n  this.privateKeyJwk = privateKeyJwk;\n  this.did = publicKeyJwkToIonDid(publicKeyJwk);\n};","map":{"version":3,"sources":["/Users/naohirofujie/Develop/MSVC/bbwallet/browser-wallet/wallet/modules/index.ts"],"names":["crypto","constants","did","methodName","publicKeyType","keyId","jwt","header","alg","payload","iss","iat","exp","jwk","kty","crv","ecdh","hash","type","fc","pem","pre","post","asn1","base64url","encode","unencoded","Buffer","from","toString","replace","decode","encoded","length","JSON","parse","split","multihash","data","digest","createHash","update","prefix","concat","generateJti","randomBytes","generatePrivateKey","privateKeyToPem","privateKey","asn1Base64","privateKeyToJwk","privateKeyBuffer","createECDH","setPrivateKey","pub","getPublicKey","publicKeyJwk","x","slice","y","privateKeyJwk","d","publicKeyJwkToIonDid","id","canonical_jwk","stringify","commitment_hash","patches","action","document","public_keys","purpose","canonical_delta","update_commitment","delta","delta_hash","canonical_suffix_data","recovery_commitment","didUniqueSuffix","suffix_data","shortFormDid","longFormDid","Wallet","siop","options","jti","kid","sub_jwk","sign","encodedHeader","encodedPayload","message","signature","createSign","result"],"mappings":"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","sourcesContent":["import crypto from \"crypto\";\n\nexport const constants = {\n  did: {\n    methodName: \"ion\",\n    publicKeyType: \"EcdsaSecp256k1VerificationKey2019\",\n    keyId: \"signingKey\",\n  },\n  jwt: {\n    header: {\n      alg: \"ES256K\",\n    },\n    payload: {\n      iss: \"https://self-issued.me\",\n      iat: 0,\n      exp: 9999999999,\n    },\n  },\n  jwk: {\n    kty: \"EC\",\n    crv: \"P-256K\",\n  },\n  ecdh: {\n    crv: \"secp256k1\",\n  },\n  hash: {\n    type: \"sha256\",\n    fc: 0x12,\n  },\n  pem: {\n    pre: \"-----BEGIN EC PRIVATE KEY-----\\n\",\n    post: \"\\n-----END EC PRIVATE KEY-----\",\n  },\n  asn1: {\n    pre: \"302e0201010420\",\n    post: \"a00706052b8104000a\",\n  },\n};\n\nexport const base64url = {\n  encode: (unencoded) => {\n    return Buffer.from(unencoded)\n      .toString(\"base64\")\n      .replace(/\\+/g, \"-\")\n      .replace(/\\//g, \"_\")\n      .replace(/=+$/, \"\");\n  },\n  decode: (encoded) => {\n    encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    while (encoded.length % 4) {\n      encoded += \"=\";\n    }\n    return Buffer.from(encoded, \"base64\").toString(\"utf8\");\n  },\n};\n\nexport const jwt = {\n  decode: (jwt) => {\n    const payload = JSON.parse(base64url.decode(jwt.split(\".\")[1]));\n    return payload;\n  },\n};\n\nexport const multihash = (data) => {\n  const digest = crypto.createHash(constants.hash.type).update(data).digest();\n  const prefix = Buffer.from([constants.hash.fc, digest.length]);\n  return Buffer.concat([prefix, digest]);\n};\n\nexport const generateJti = () => {\n  return crypto.randomBytes(16).toString(\"hex\");\n};\n\nexport const generatePrivateKey = () => {\n  return crypto.randomBytes(32).toString(\"hex\");\n};\n\nexport const privateKeyToPem = (privateKey) => {\n  const asn1 = `${constants.asn1.pre}${privateKey}${constants.asn1.post}`;\n  const asn1Base64 = Buffer.from(asn1, \"hex\").toString(\"base64\");\n  const pem = `${constants.pem.pre}${asn1Base64}${constants.pem.post}`;\n  return pem;\n};\n\nexport const privateKeyToJwk = (privateKey) => {\n  const privateKeyBuffer = Buffer.from(privateKey, \"hex\");\n  const ecdh = crypto.createECDH(constants.ecdh.crv);\n  ecdh.setPrivateKey(privateKeyBuffer);\n  const pub = ecdh.getPublicKey();\n  const publicKeyJwk = {\n    kty: constants.jwk.kty,\n    crv: constants.jwk.crv,\n    x: base64url.encode(pub.slice(1, 32 + 1)),\n    y: base64url.encode(pub.slice(32 + 1)),\n  };\n  const privateKeyJwk = {\n    d: base64url.encode(privateKeyBuffer),\n    ...publicKeyJwk,\n  };\n  return { publicKeyJwk, privateKeyJwk };\n};\n\nexport const publicKeyJwkToIonDid = (publicKeyJwk) => {\n  const id = constants.did.keyId;\n  const canonical_jwk = JSON.stringify(publicKeyJwk);\n  const commitment_hash = base64url.encode(multihash(canonical_jwk));\n  const patches = [\n    {\n      action: \"replace\",\n      document: {\n        public_keys: [\n          {\n            id,\n            type: constants.did.publicKeyType,\n            jwk: publicKeyJwk,\n            purpose: [\"auth\", \"general\"],\n          },\n        ],\n      },\n    },\n  ];\n  const canonical_delta = JSON.stringify({\n    update_commitment: commitment_hash,\n    patches,\n  });\n  const delta = base64url.encode(canonical_delta);\n  const delta_hash = base64url.encode(multihash(canonical_delta));\n  const canonical_suffix_data = JSON.stringify({\n    delta_hash,\n    recovery_commitment: commitment_hash,\n  });\n  const didUniqueSuffix = base64url.encode(multihash(canonical_suffix_data));\n  const suffix_data = base64url.encode(canonical_suffix_data);\n  const shortFormDid = `did:${constants.did.methodName}:${didUniqueSuffix}`;\n  const longFormDid = `${shortFormDid}?-${constants.did.methodName}-initial-state=${suffix_data}.${delta}`;\n  return longFormDid;\n};\n\nexport class Wallet {\n  privateKey;\n  publicKeyJwk;\n  privateKeyJwk;\n  did;\n  constructor(privateKey?) {\n    this.privateKey = privateKey ? privateKey : generatePrivateKey();\n    const { publicKeyJwk, privateKeyJwk } = privateKeyToJwk(this.privateKey);\n    this.publicKeyJwk = publicKeyJwk;\n    this.privateKeyJwk = privateKeyJwk;\n    this.did = publicKeyJwkToIonDid(publicKeyJwk);\n  }\n\n  siop = (options?) => {\n    const jti = generateJti();\n    const header = {\n      alg: constants.jwt.header.alg,\n      kid: `${this.did}#${constants.did.keyId}`,\n    };\n    const payload = {\n      iss: constants.jwt.payload.iss,\n      iat: constants.jwt.payload.iat,\n      exp: constants.jwt.payload.exp,\n      did: this.did,\n      jti,\n      sub_jwk:this.publicKeyJwk,\n      ...options,\n    };\n    return this.sign(header, payload);\n  };\n\n  sign = (header, payload) => {\n    const pem = privateKeyToPem(this.privateKey);\n    const encodedHeader = base64url.encode(JSON.stringify(header));\n    const encodedPayload = base64url.encode(JSON.stringify(payload));\n    const message = `${encodedHeader}.${encodedPayload}`;\n    const signature = base64url.encode(\n      crypto.createSign(constants.hash.type).update(message).sign(pem)\n    );\n    const result = `${encodedHeader}.${encodedPayload}.${signature}`;\n    return result;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}